#!/usr/bin/env python3
# Copyright (C) 2025 Clyso
# SPDX-License-Identifier: AGPL-3.0-or-later


import os
import yaml
import argparse
import subprocess
import json

from clyso.ceph.ai import generate_result

CONFIG_FILE = 'copilot.yaml'

def jsoncmd(command):
    with open(os.devnull, 'w') as devnull:
        out = subprocess.check_output(command.split(), stderr=devnull)
    return json.loads(out)

def collect():
    assert False, "collect: not implemented"

def pretty_result(result):
    # Load the JSON data
    json_data = json.loads(result)

    # Print the summary
    print(f"Overall score: {json_data['summary']['score']:g} out of {json_data['summary']['max_score']}")
    print(f"Grade: {json_data['summary']['grade']}
")

    # Loop over the sections
    for section in json_data['sections']:
        print(f"Section: {section['id']}")
        print(f"Score: {section['score']:g} out of {section['max_score']}")
        print(f"Grade: {section['grade']}")
        print("Checks:")
        for check in section['checks']:
            print(f"  - ID: {check['id']}")
            print(f"    Result: {check['result']}")
            print(f"    Summary: {check['summary']}")
            print(f"    Details:")
            for detail in check['detail']:
                print(f"      - {detail}")
            if not check['detail']:
                print(f"      - None")
            print(f"    Recommendations:")
            for recommend in check['recommend']:
                print(f"      - {recommend}")
            if not check['recommend']:
                print(f"      - None")
            print("")
        if not section['checks']:
            print("  - None")
            print("")


def subcommand_checkup(args):
    if args.ceph_report_json:
        with open(args.ceph_report_json, 'r') as file:
            report = json.load(file)
    else:
        report = collect()

    result = generate_result(report_json = report)
    pretty_result(result.dump())


def get_tuning_profiles():
    return {
        'balanced': {
            'description': 'Balanced tuning for general-purpose workloads.',
            'settings': {
                'osd': {
                    'osd_op_threads': 8,
                },
            },
            'devices': 'hdd|mixed|ssd|nvme',
        },
        'performance': {
            'description': 'Optimized for high-performance workloads.',
            'settings': {
                'osd': {
                    'osd_op_threads': 16,
                    'osd_memory_target': 2147483648,
                },
            }
        },
        'capacity': {
            'description': 'Optimized for large-scale, capacity-oriented workloads.',
            'settings': {
                'osd': {
                    'osd_op_threads': 4,
                },
            }
        },
        'lowmem': {
            'description': 'Optimized for low memory nodes, e.g. edge devices.',
            'settings': {
                'osd': {
                    'osd_memory_target': 2147483648,
                },
            }
        }
    }

def profile_list(args):
    profiles = get_tuning_profiles()
    print("Available tuning profiles:")
    for name, profile in profiles.items():
        print(f"- {name}: {profile['description']}")
    profile_show(args)

def profile_set(args):
    profile_name = args.profilename
    profiles = get_tuning_profiles()
    if profile_name not in profiles:
        print(f"Error: Unknown profile '{profile_name}'.")
        profile_list(args)
        return

    with open(CONFIG_FILE, 'w') as f:
        yaml.dump({'active_profile': profile_name}, f)

    print(f"Successfully set active tuning profile to '{profile_name}'.")

def profile_show(args):
    if not os.path.exists(CONFIG_FILE):
        print("Error: No active tuning profile found.")
        return

    with open(CONFIG_FILE, 'r') as f:
        config = yaml.safe_load(f)

    active_profile = config.get('active_profile')
    if not active_profile:
        print("Error: No active tuning profile found.")
        return

    print(f"Active tuning profile: {active_profile}")

def profile_verify(args):
    if not os.path.exists(CONFIG_FILE):
        print("Error: No active tuning profile found.")
        return

    with open(CONFIG_FILE, 'r') as f:
        config = yaml.safe_load(f)

    active_profile = config.get('active_profile')
    if not active_profile:
        print("Error: No active tuning profile found.")
        return

    profiles = get_tuning_profiles()
    profile = profiles.get(active_profile)
    if not profile:
        print(f"Error: Unknown profile '{active_profile}'.")
        return

    settings = profile.get('settings')
    if not settings:
        print(f"Error: No settings found for profile '{active_profile}'.")
        return

    for key, value in settings.items():
        ceph_value = run_ceph_command(['config', 'get', 'global', key])
        if str(value) != ceph_value.strip():
            print(f"Error: Mismatched setting '{key}': expected '{value}', found '{ceph_value.strip()}'.")
            return

    print("Current Ceph configuration matches the active profile.")


def toolkit_upmapremapped(args):
    print('upmap-remapped is coming soon. For now, github.com/clyso/ceph-scripts/tools/upmap/ for more info')
    return

def run_ceph_command(args):
    command = ['ceph']
    command.extend(args)
    try:
        output = subprocess.check_output(command)
        print(output.decode('utf-8'))
    except subprocess.CalledProcessError as e:
        print(f"Error: {e.output.decode('utf-8')}")
        exit(1)

def main():
    # Create the top-level parser
    parser = argparse.ArgumentParser(prog='copilot', description='Ceph Copilot: Your Expert Ceph Assistant.')
    subparsers = parser.add_subparsers(required=True, title='subcommands',
                                       description='valid subcommands',
                                       help='additional help')

    # create the parser for the "checkup" command
    parser_checkup = subparsers.add_parser('checkup', help='Perform an overall health and safety check on the cluster')
    parser_checkup.add_argument('--ceph_report_json', type=str, help='ceph_report_json help')
    parser_checkup.set_defaults(func=subcommand_checkup)

    # Create the parser for the "profile" command
    parser_profile = subparsers.add_parser('profile', help='View and apply Ceph Tuning Profiles')
    profile_subparsers = parser_profile.add_subparsers(required=True)

    # Create the parser for the "profile list" command
    parser_profile_list = profile_subparsers.add_parser('list', help='List available Ceph tuning profiles')
    parser_profile_list.set_defaults(func=profile_list)

    # Create the parser for the "profile set" command
    parser_profile_set = profile_subparsers.add_parser('set', help='Set a Ceph tuning profile')
    parser_profile_set.add_argument('profilename', type=str, help='profilename help')
    parser_profile_set.set_defaults(func=profile_set)

    # Create the parser for the "profile show" command
    parser_profile_show = profile_subparsers.add_parser('show', help='Show the currently used Ceph tuning profile')
    parser_profile_show.set_defaults(func=profile_show)

    # Create the parser for the "profile verify" command
    parser_profile_verify = profile_subparsers.add_parser('verify', help='Check if the cluster configuration matches the profile recommendations')
    parser_profile_verify.set_defaults(func=profile_verify)

    # Create the parser for the "toolkit" command
    parser_toolkit = subparsers.add_parser('toolkit', help='A selection of useful Ceph Tools')
    toolkit_subparsers = parser_toolkit.add_subparsers(required=True)

    # Create the parser for the "toolkit upmap-remapped" command
    parser_toolkit_upmapremapped = toolkit_subparsers.add_parser('upmap-remapped', help='[Advanced] Used to map PGs to their current location, pausing most backfills')
    parser_toolkit_upmapremapped.set_defaults(func=toolkit_upmapremapped)

    # Parse the arguments and call the appropriate function
    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
